1)Parameter passing: passing parameter by value vs by reference, passing array as constant pointer.

#include<iostream>
using namespace std;
void passbyvalue(int x, int y)
{
int sum=0,t=0;
sum=x+y;
cout<<"Addition through pass by value is "<<sum<<endl;
t=x;
x=y;
y=t;
cout<<"Swapping through pass by value "<<x<<" "<<y<<endl;
}
void passbyreference(int &x, int &y)
{
int sum=0,t;
sum=x+y;
cout<<"Addition through pass by reference is "<<sum<<endl;
t=x;
x=y;
y=t;
cout<<"Swapping through pass by value "<<x<<" "<<y<<endl;
}
void passArray(int *ar,int n)
{
int sum=0;
for(int i=0;i<n;i++)
{
cout<<"Enter "<<i+1<<" element " ;
cin>>ar[i];
sum=sum+ar[i];
}
cout<<"Sum of given array is "<<sum<<endl;
}
int main()
{
int a,b,n;
cout<<"Enter two values for call by value & refrence ";
cin>>a>>b;
passbyvalue(a,b);
cout<<"Pass by values "<<a<<b<<endl;
passbyreference(a,b);
cout<<"Enter required no. of elements for passing array"<<endl;
cin>>n;
int ar[n];
passArray(ar,n);
return 0;
}
output:
Addition through pass by value is 7
Swapping through pass by value 4 3
Pass by values 34
Addition through pass by reference is 7
Swapping through pass by value 4 3
Enter required no. of elements for passing array
3
Enter 1 element 4
Enter 2 element 5
Enter 3 element 6
Sum of given array is 15

2)Function overloading: writing string operations like strcat and strncat, strcpy and strncpy as overloaded functions.
#include<iostream>
#include<string>
using namespace std;
void strcpy(string,int);
void strcpy(string);
void strcat(string,string);
void strcat(string,string,int);
int main()
{
int ch,n;
string str1,str2;
while(1)
{
cout<<"\n 1:string n concatenation\t 2:string concatenation\t 3:stringcopy\t 4:string n copy\t5:exit"<<endl;
cout<<"choose an option"<<endl;
cin>>ch;
switch(ch)
{case 1:strcat(str1,str2,n);
break;
case 2:strcat(str1,str2);
break;
case 3:strcpy(str1);
break;
case 4:strcpy(str1,n);
break;
//case 5:exit(0);
default:cout<<"entered wrong choice"<<endl;
}
}
}
void strcat(string first,string second,int n)
{ string s;
int i;
cout<<"enter 2 strings"<<endl;
cin>>first>>second;
s=first+second;
cout<<"enter no of letters to be shown after concatenation"<<endl;
cin>>n;
for(i=0;i<n;i++)
cout<<s[i];
}
void strcat(string str1,string str2)
{cout<<"enter two strings"<<endl;
cin>>str1>>str2;
cout<<"the required concatenated string is"<<str1.append(str2)<<endl;
}
void strcpy(string a)
{string b;
cout<<"enter a string"<<endl;
cin>>a;
b=a;
cout<<"the given string is copied as"<<b<<endl;
}
void strcpy(string c,int p)
{string d;
int i;
cout<<"enter the string"<<endl;
cin>>c;
d=c;
cout<<"enter the no of letters to be executed"<<endl;
cin>>p;
cout<<"the required string is"<<endl;
for(i=0;i<p;i++)
cout<<d[i];
}
output:
1:string concatenation  2:string concatenation  3:stringcopy    4:string n copy        5:exit
choose an option
1
enter 2 strings
lanka revathippathi
enter no of letters to be shown after concatenation
6
lankar
 1:string concatenation  2:string concatenation  3:stringcopy    4:string n copy        5:exit
choose an option
2
enter two strings
revanth csbs
the required concatenated string isrevanthcsbs

 1:string concatenation  2:string concatenation  3:stringcopy    4:string n copy        5:exit
choose an option
3
enter a string
revanth
the given string is copied asrevanth

 1:string concatenation  2:string concatenation  3:stringcopy    4:string n copy        5:exit
choose an option
4
enter the string
revanth
enter the no of letters to be executed
4
the required string is
reva

3)Dynamically allocating space for a pointer depending on input and doing this repeatedly, depending on different inputs and finally de-allocating the pointer.
#include<iostream>
#include<string>
using namespace std;
int main()
{ string s,s1;
cout<<"Enter any of the following \n integer\ncharacter\nstring\ndouble\nfloat\nexit"<<endl;
while(1)
{
cout<<"Enter input type "<<endl;
cin>>s;
if(s=="character")
{
char *c = new char;
cout<<"Enter character "<<endl;
cin>>c;
cout<<"Entered is "<<*c<<endl;
delete c;
}
else if (s=="string")
{
string *s1 = new string;
cout<<"Enter a line "<<endl;
getline(cin,*s1);
getline(cin,*s1);
cout<<"Entered is "<<*s1<<endl;
delete s1;
}
else if(s=="integer")
{
int *i = new int;
cout<<"Enter a number "<<endl;
cin>>*i;
cout<<"Entered is "<<*i<<endl;
delete i;
}
else if(s=="double" || "float")
{
double *d = new double;
cout<<"Enter a number "<<endl;
cin>>*d;
cout<<"Entered is "<<*d<<endl;
delete d;
}
else
{
cout<<"Enter valid type "<<endl;
}
}
return 0;
}
output:
Enter any of the following 
 integer
character
string
double
float
exit
Enter input type 
integer
Enter a number 
7654
Entered is 7654
Enter input type 
character
Enter character 
R
Entered is R
Enter input type 
string
Enter a line 
revanth
Entered is revanth
Enter input type 
float
Enter a number 
5.645
Entered is 5.645
Enter input type 
double
Enter a number 
7694.4589546
Entered is 7694.46

4)Define class complex with all possible operations: constructor, destructor, copy constructor, assignment operator with the data members stored as pointer to integers.
#include<iostream>
using namespace std;
class Complex
{
int *real,*img;
public:
Complex()//Default COnstructor
{
real=0;
img=0;
}
Complex(int x, int y) //Constructor
{
real =new int;
img=new int;
*real = x;
*img=y;
cout<<"Values inside Constructor is "<<*real<<"+i"<<*img<<endl;
}
Complex(const Complex &c) //Copy Constructor
{
real= c.real;
img=c.img;
cout<<"Values inside Copy Constructor "<<*real<<"+i"<<*img<<endl;
}
Complex operator=(const Complex &ca)
{
real = ca.real;
img = ca.img;
cout<<"Values using Assignment Operators "<<*real<<"+i"<<*img<<endl;
}
~Complex() //Destructor
{
cout<<"Destructor called "<<endl;
}
};
int main()
{
Complex c1(20,30);
Complex c2(10,40);
Complex c3;
//Using Assignmnet operator
c3=c1;
//Using Copy Contructor
Complex c4(c1);
}
output:
Values inside Constructor is 25+i330
Values inside Constructor is 100+i340
Values using Assignment Operators 25+i330
Destructor called 
Values inside Copy Constructor 25+i330
Destructor called 
Destructor called 
Destructor called 
Destructor called

5)Define class vector of integers with all possible operations like constructor, destructor, copy constructor and assignment operators.
#include<iostream>
using namespace std;
class vector
{
int n,i,*a;
public:
vector()
{
}
vector(int n):n(n)
{
a=new int[n];
cout<<"enter "<<n<<" elements into the vector:"<<endl;
for(i=0;i<n;++i)
{
cin>>a[i];
}
cout<<"displaying elements using constructor"<<endl;
for(i=0;i<n;i++)
{
cout<<a[i]<<" ";
}

cout<<endl;
}
vector(vector &t)
{
n=t.n;
a=t.a;
cout<<"after assigning using copy cons values are :"<<endl;
for(int i=0;i<n;++i){
cout<<a[i]<<" ";
}
cout<<endl;
}
vector&operator=(const vector&t)
{
int n=t.n;
a=t.a;
cout<<"after assigning values using =operator are:"<<endl;
for(int i=0;i<n;++i){
cout<<a[i]<<" ";
}
cout<<endl;
}
~vector()
{cout<<"destructor called"<<endl;
}
};
int main()
{
vector obj1(4);
vector obj2(obj1);
vector obj3;
obj3=obj1;
return 0;
}
output:
enter 4 elements into the vector:
4 
3 
1 
6
displaying elements using constructor
4 3 1 6 
after assigning using copy cons values are :
4 3 1 6 
after assigning values using =operator are:
4 3 1 6 
destructor called
destructor called
destructor called

6)Define class matrix of integers with all possible operations like constructor, destructor, copy constructor and assignment operators.
#include<iostream>
using namespace std;
class matrix
{
int row,col,i,j;
int **m;//While declaring 2d array we should use **m if 1d array *m
public:
matrix()//Default constructor
{
}
matrix(int r,int c)
{
row=r;
col=c;
m= new int*[row];
for(i=0;i<row;i++)
{
m[i]=new int [col];
}// If declaring a 2d array dynamically we have to use above 5 lines
}
matrix(const matrix & cpy)//Copy Constructor
{
cout<<"Copy constructor invoked "<<endl;
row=cpy.row;
col=cpy.col;
m=cpy.m;
for(i=0;i<row;i++)
{
for(j=0;j<col;j++)
{
m[i][j]=cpy.m[i][j];
}
}
}
matrix operator =(const matrix &rhs)
{
row=rhs.row;
col=rhs.col;
m=new int *[row];
for(i=0;i<row;i++)
{
m[i]=new int [col];
}
for(i=0;i<row;i++)
{
for(j=0;j<col;j++)
{
m[i][j]=rhs.m[i][j];
}
}
return *this;
}
void print()
{
for(i=0;i<row;i++)
{
for(j=0;j<col;j++)
{
cout<<m[i][j]<<" ";
}
cout<<endl;
}
}
void enter()
{
m= new int*[row];
for(i=0;i<row;i++)
{
m[i]=new int [col];
}
cout<<"Enter values of matrix"<<endl;
for(i=0;i<row;i++)
{
for(j=0;j<col;j++)
{
cin>>m[i][j];
}
}
}
~matrix()//Destructor
{
}
};
int main()
{
matrix m1(3,3),m2(2,2);
cout<<"Enter matrix 1 elements "<<endl;
m1.enter();
cout<<"Enter matrix 2 elements "<<endl;
m2.enter();
matrix m3(3,3);
cout<<"Assignment operator "<<endl;
m3=m1;
m3.print();
cout<<"Using copy constructor "<<endl;
matrix m4(m2);
m4.print();
return 0;
}
output:
Enter matrix 1 elements 
Enter values of matrix
1 2 5
4 6 7
7 3 6
Enter matrix 2 elements 
Enter values of matrix
3 7
1 8
Assignment operator 
Copy constructor invoked 
1 2 5 
4 6 7 
7 3 6 
Using copy constructor 
Copy constructor invoked 
3 7 
1 8
 
7)Define class matrix of integers using vector, with all possible operations like constructor, destructor, copy constructor and assignment operators.
#include<vector>
#include<algorithm>
#include<iostream>
using namespace std;
class matrix
{
int rows,col,i,j;
vector<vector<int> >v;
public:
matrix()//Default constructor
{
}
matrix(int r,int c)
{
rows=r;
col=c;
}
matrix& operator =(const matrix& rhs)
{
cout<<"Displaying Assignment operator "<<endl;
rows=rhs.rows;
col=rhs.col;
v=rhs.v;
return *this;
}
matrix(const matrix &cpy)
{
cout<<"Printing using copy constructor "<<endl;
rows = cpy.rows;
col=cpy.col;
v=cpy.v;
}
void enter()
{
int num;
cout<<"Enter "<<rows<<"x"<<col<<" matrix"<<endl;
for(i=0;i<rows;i++)
{
vector<int> v1;
for(j=0;j<col;j++)
{
cin>>num;
v1.push_back(num);
}
v.push_back(v1);
}
}
void print()
{
for (int i = 0; i < v.size(); i++)
{
for (int j = 0; j < v[i].size(); j++)
{
cout << v[i][j] << " ";
}
cout<<endl;
}
}
~matrix()//Destructor
{
}
};
int main()
{
matrix m1(3,3);
m1.enter();
matrix m2;
m2=m1;
m2.print();
matrix m3(m1);
m3.print();
return 0;
}
output:
Enter 3x3 matrix
1 2 3
45 23 67
12 34 78
Displaying Assignment operator 
1 2 3 
45 23 67 
12 34 78 
Printing using copy constructor 
1 2 3 
45 23 67 
12 34 78 
8)8. Defineclass stack,queue,linked-list,array,set usingsomedata-type(int)withdatamembers kept as private and functions kept in both protected and public sections.
#include<iostream>
#include <cstdlib>
#include<set>
#define size 20
#define sizeq 20
using namespace std;
int top=-1;
int front =0;
int rear=0;
struct Node {
int data;
struct Node *next;
}*head=NULL,*temp,*ptr;
class stackss
{
int data;
//int top=-1;
int stacks[size];
public:
void push(int data)
{
if(top>=size)
{
cout<<"Stack is full "<<endl;
}
else
{
top=top+1;
stacks[top]=data;
}
}
void pop()
{
int temp;
if(top<=0)
{
cout<<"Stack is empty "<<endl;
}
else
{
temp=stacks[top];
top=top-1;
cout<<"Data popped is "<<temp<<endl;
}
}
void stack_print()
{
int i=top;
while(i>=0)
{
cout<<stacks[i]<<endl;
i--;
}
}
};
class queues
{
int queue[sizeq];
int data;
public:
void push(int data)
{
queue[rear]=data;
rear++;
}
void pop()
{
int temp;
temp=queue[front];
front++;
cout<<"Element popped is "<<temp<<endl;
}
void queue_print()
{
int i=front;
while(i<rear)
{
cout<<queue[i]<<endl;
i++;
}
}
};
class linked_list
{
public:
void insert(int data)
{
temp=(struct Node *)malloc(sizeof(struct Node));
temp->data=data;
temp->next=NULL;
if(head==NULL)
{
head=temp;
}
else
{
temp->next=head;
head=temp;
}
}
void delet()
{
int t;
ptr=head;
t=ptr->data;
head=ptr->next;
ptr->next=NULL;
free(ptr);
cout<<"Element deleted is "<<t<<endl;
}
void linked_print()
{
ptr=head;
while(ptr!=NULL)
{
cout<<ptr->data<<endl;
ptr=ptr->next;
}
}
};
class arrays
{
int a[10],n;
public:
arrays()
{
}
void insert(int n)
{
int i=0;
for(i=0;i<n;i++)
{
cout<<"Enter data "<<endl;
cin>>a[i];
}
}
void arrays_print(int n)
{
for(int i=0;i<n;i++)
{
cout<<a[i]<<endl;
}
}
};
int main()
{
cout<<"Stack Operations "<<endl;
stackss s;
s.push(40);
s.push(4);
s.push(57);
s.stack_print();
s.pop();
s.pop();
s.stack_print();
cout<<"Queue operations "<<endl;
queues q;
q.push(150);
q.push(30);
q.push(160);
q.queue_print();
q.pop();
q.pop();
q.queue_print();
cout<<"Linked list operations "<<endl;
linked_list l;
l.insert(27);
l.insert(78);
l.insert(9);
l.linked_print();
l.delet();
l.delet();
cout<<"Array operations are "<<endl;
arrays a1;
a1.insert(4);
cout<<"array elements are:\n";
a1.arrays_print(4);
cout<<"Set operations are "<<endl;
set<int> s1;
s1.insert(11);
s1.insert(26);
s1.insert(3);
cout<<"Set values are "<<endl;
set<int>::iterator it1;
for(it1=s1.begin();it1!=s1.end();it1++)
{
cout<<*it1<<" ";
}
s1.erase(3);
cout<<endl<<"After deleting element set values are "<<endl;
set<int>::iterator it2;
for(it2=s1.begin();it2!=s1.end();it2++)
{
cout<<*it2<<" ";
}
}
output:
Stack Operations 
57
4
40
Data popped is 57
Data popped is 4
40
Queue operations 
150
30
160
Element popped is 150
Element popped is 30
160
Linked list operations 
9
78
27
Element deleted is 9
Element deleted is 78
Array operations are 
Enter data 
3
Enter data 
23
Enter data 
56
Enter data 
89
array elements are:
3
23
56
89
Set operations are 
Set values are 
3 11 26 
After deleting element set values are 
11 26
9)Define class complex with all possible operators: constructor, destructor, copy constructor, assignment operator and operators >, =, <=, ==, ++ (pre and post), +, +=, ( ), with the data members stored as pointer to integers.
#include<iostream>
using namespace std;
class Complex
{
int real,imag,mag;
public:
Complex()
{
}
Complex(int r,int i)
{
real=r;
imag=i;
}
Complex operator () (int r,int i,int m)
{
Complex d;
d.real=r;
d.imag=i;
d.mag=m;
return d;
}
Complex operator > (const Complex &rhs)
{
if(real>rhs.real && imag>rhs.imag)
{
cout<<"1st object is larger "<<endl;
}
else
{
cout<<"2nd object is larger "<<endl;
}
}
Complex operator < (const Complex&rhs)
{
if(real<rhs.real&& imag<rhs.imag)
{
cout<<"1st object is smaller "<<endl;
}
else
{
cout<<"2nd object is smaller "<<endl;
}
}
Complex operator >= (const Complex&rhs)
{
if(real>rhs.real && imag>rhs.imag)
{
cout<<"1st object is larger "<<endl;
}
else if(real==rhs.real && imag==rhs.imag)
{
cout<<"Both are equal "<<endl;
}
else
{
cout<<"2nd object is larger "<<endl;
}
}
Complex operator <= (const Complex&rhs)
{
if(real<rhs.real&& imag<rhs.imag)
{
cout<<"1st object is smaller "<<endl;
}
else if(real == rhs.real && imag == rhs.imag)
{
cout<<"Both are equal "<<endl;
}
else
{
cout<<"2nd object is smaller "<<endl;
}
}
Complex operator ++() //Pre Increment
{
Complex c;
c.real=++real;
c.imag=++imag;
return c;
}
Complex operator ++(int) //Post Increment
{
Complex c;
c.real=real++;
c.imag=imag++;
return c;
}
Complex operator + (const Complex &rhs)
{
Complex c;
c.real=real+rhs.real;
c.imag=imag+rhs.imag;
return c;
}
Complex operator += (const Complex &rhs)
{
Complex c;
c.real=real+rhs.real;
c.imag=imag+rhs.imag;
return c;
}
Complex operator = (const Complex &rhs)
{
real=rhs.real;
imag=rhs.imag;
}
void print()
{
Complex c;
cout<<"Real value is "<<real<<endl;
cout<<"Imaginary value is "<<imag<<endl;
}
void printm()
{
Complex c;
cout<<"Real value is "<<real<<endl;
cout<<"Imaginary value is "<<imag<<endl;
cout<<"Magnitude part is "<<mag<<endl;
}
~Complex() //Destructor
{
}
};
int main()
{
Complex c1(61,29),c2(93,34);
c1>c2;
c1<c2;
cout<<"Post Incrementing "<<endl;
c1++;
c1.print();
cout<<"Pre Incrementing "<<endl;
++c2;
c2.print();
cout<<"Adding two classes "<<endl;
Complex c3=c1+c2;
c3.print();
cout<<"Adding using short hand operators "<<endl;
c3.operator +=(c2);
c3.print();
cout<<"Assignment operator overloading "<<endl;
Complex c4;
c4=c1;
c4.print();
cout<<"Paranthesis operator overloading "<<endl;
Complex c5=c2(5,12,13);
c5.printm();
}
output:
2nd object is larger 
1st object is smaller 
Post Incrementing 
Real value is 62
Imaginary value is 30
Pre Incrementing 
Real value is 94
Imaginary value is 35
Adding two classes 
Real value is 156
Imaginary value is 65
Adding using short hand operators 
Real value is 156
Imaginary value is 65
Assignment operator overloading 
Real value is 62
Imaginary value is 30
Paranthesis operator overloading 
Real value is 5
Imaginary value is 12
Magnitude part is 13
10)
